<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>月初</title>
  
  <subtitle>别打我，我知道我很蠢。。。  (联系qq1451595214,注明来意)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://baiyuechu.github.io/"/>
  <updated>2018-10-14T13:57:53.984Z</updated>
  <id>http://baiyuechu.github.io/</id>
  
  <author>
    <name>月初</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>狼的孩子雨和雪</title>
    <link href="http://baiyuechu.github.io/2018/10/14/%E7%8B%BC%E7%9A%84%E5%AD%A9%E5%AD%90%E9%9B%A8%E5%92%8C%E9%9B%AA/"/>
    <id>http://baiyuechu.github.io/2018/10/14/狼的孩子雨和雪/</id>
    <published>2018-10-14T12:35:46.876Z</published>
    <updated>2018-10-14T13:57:53.984Z</updated>
    
    <content type="html"><![CDATA[<p>一部日漫电影，导演细守田<a id="more"></a><br>其主要讲述了一个伟大母亲的故事（注意，下文剧情剧透）<br>故事开篇，女主遇上狼爸（狼人），生下一女一男（小狼人），不久狼爸不幸去世，女主带着两狼孩无法适应城市生活，决定搬到乡下。<br>乡间的劳作对于一直呆在城里的生活的女主来说是很困难的，好在有善良的农民的帮助。<br>孩子慢慢长大，女孩表现出狼的性格，追赶小动物，标记领地等行为，而男孩却很胆小。<br>等到上学的年龄，女孩见识到了人类的文化，渐渐的将狼性隐藏起来；而男孩因为一次抓捕山雀的举动，而渐渐释放狼性。<br>最终，男孩女孩走上了不同的道路，男孩归于山林，女孩融于人类，而女主欣慰于终于养大了两狼孩。</p><p>蹩脚的文笔仅仅是略微叙述故事的发展，完全不能将这个作品的灵魂展露丝毫。这是一部非常值得一看的亲情作品，主要歌颂了母爱的伟大。<br>不过该影片让我难受的有以下4点：<br>1、狼爸的过早离开（如果没有过早离开，他们一家会不会过的更幸福一点呢？小狼人的成长会不会更顺利呢？当然，如果没有过早离开，作品的本意可能就无法展现了。）<br>2、狼孩女孩对于对方的不理解。女孩见识到人类的文化后，觉得应该去融入人类，而狼孩却觉得他流着狼的血液，应该归于山林。两姐弟为了自己观点甚至大打出手，作品最后也没有描绘两姐弟是否理解对方<br>3、狼孩女孩对于对方的不理解而产生的矛盾，女主没有给出一些人生的指引或教导，或者说全篇都没有描述女主对于孩子人生道路的言传，身教当然有，但对于人生的抉择上来说，却显得不太合适了<br>4、女主最后独自看着狼爸的照片，感叹于终于养大了两孩子，那欣慰的容颜却让我感到无比寂寞，自己最亲的人全都离开自己了，以后的日夜都要自己一个人度过了，这种父母盼着见到子女的心情我却在这一刻突然体会到了</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=522693&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一部日漫电影，导演细守田
    
    </summary>
    
      <category term="动漫" scheme="http://baiyuechu.github.io/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
      <category term="动漫" scheme="http://baiyuechu.github.io/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>刺客伍六七</title>
    <link href="http://baiyuechu.github.io/2018/10/05/%E5%88%BA%E5%AE%A2%E4%BC%8D%E5%85%AD%E4%B8%83/"/>
    <id>http://baiyuechu.github.io/2018/10/05/刺客伍六七/</id>
    <published>2018-10-05T14:51:55.409Z</published>
    <updated>2018-10-13T14:29:17.856Z</updated>
    
    <content type="html"><![CDATA[<p>很不错的一部国产动漫，集搞笑，热血，情怀，感动，反思于一身<a id="more"></a><br>支线小故事让人捧腹的同时又不禁思考一些社会现象<br>内裤收藏男只是收藏的东西特殊一点，又没有对社会造成什么危害，他一不偷，二不抢，却被所有人不理解，居委会大妈代表正义想消灭他，可是收藏靠自己劳动赚取（或捡拾）的内裤，有什么错吗？<br>，为什么不能被社会接纳？<br>还有为了孙子欺诈他人的老奶奶，却被自己的儿子花钱请567刺杀<br>还有卖裤子求567保卫小岛的大爷<br>还有猫和狗的爱情<br>还有老实耿直的保镖大春<br>。。。。。。<br>还有主线大战科技国王子，燃的不行，让我看了好几遍</p><p>真的是一部很棒的国产动漫<br>在我看来，唯一招黑的一点是里面出现的星爷搞笑元素，不过这种个人感受或喜好的问题，丝毫不影响他是一部好作品，力荐</p><p>《剪刀刺客》网易没版权，这首也是当时写给刺客伍六七的，导演最后没有选用，只能放这首了</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=568765498&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很不错的一部国产动漫，集搞笑，热血，情怀，感动，反思于一身
    
    </summary>
    
      <category term="动漫" scheme="http://baiyuechu.github.io/categories/%E5%8A%A8%E6%BC%AB/"/>
    
    
      <category term="动漫" scheme="http://baiyuechu.github.io/tags/%E5%8A%A8%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>时间管理</title>
    <link href="http://baiyuechu.github.io/2018/10/05/time%20Manage/"/>
    <id>http://baiyuechu.github.io/2018/10/05/time Manage/</id>
    <published>2018-10-05T14:06:13.410Z</published>
    <updated>2017-03-20T12:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间管理的七句话（摘自<a href="http://www.ruanyifeng.com/blog/2016/05/time-management.html" target="_blank" rel="noopener">阮一峰的博客</a>）<a id="more"></a></p><blockquote><p>   <code>1.进程切换非常昂贵，避免多任务，保持单进程。</code><br>   <code>2.一个人能够集中注意力的时间，是有限的。一般来说，高效工作只能持续四个小时，其余时间就都是低效工作了。</code><br>   <code>3.你的时间有限，不可能做所有事。最重要的事，应该首先做。(一个有用的技巧是，将所有任务按照&quot;重要性&quot;和&quot;紧急性&quot;两个维度，分成四个象限。第一象限优先级最高，第四象限最低。)</code><br>   <code>4.起床后，不要查看邮件和微信。</code><br>   <code>5.避免开会，因为人类已知的最浪费时间的事情，就是开会。</code><br>   <code>6.早晨4点起床，到了中午，你就完成了一天的任务。《四点起床》</code><br>   <code>7.世上并没有拖延症，只是不想做而已。如果可能，应该尽早放弃你没有意愿去做的那些事。而那些没有时间也会去做的事，才是你应该全力以赴的人生方向。</code></p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=22660295&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间管理的七句话（摘自&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/05/time-management.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰的博客&lt;/a&gt;）
    
    </summary>
    
      <category term="Live" scheme="http://baiyuechu.github.io/categories/Live/"/>
    
    
      <category term="Live" scheme="http://baiyuechu.github.io/tags/Live/"/>
    
      <category term="self management" scheme="http://baiyuechu.github.io/tags/self-management/"/>
    
  </entry>
  
  <entry>
    <title>学习方法</title>
    <link href="http://baiyuechu.github.io/2018/10/05/study/"/>
    <id>http://baiyuechu.github.io/2018/10/05/study/</id>
    <published>2018-10-05T14:06:13.394Z</published>
    <updated>2017-05-17T00:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>《软技能》一书的作者曾在书中分享过他的一个十步学习法：<a id="more"></a></p><blockquote><p>了解全局<br>确定范围<br>定义目标<br>寻找资源<br>学习计划<br>筛选资源<br>开始学习，浅尝辄止<br>动手操作，边玩边学<br>全面掌握，学以致用<br>乐为人师，融汇贯通</p></blockquote><p>金庸老爷子笔下有一“剑魔”，一生用剑经历「利剑无意」，「软剑无常」，「重剑无锋」，「木剑无俦」，「无剑无招」，最终剑已埋冢，人却求败。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《软技能》一书的作者曾在书中分享过他的一个十步学习法：
    
    </summary>
    
      <category term="study" scheme="http://baiyuechu.github.io/categories/study/"/>
    
    
      <category term="study" scheme="http://baiyuechu.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>oracle存储过程</title>
    <link href="http://baiyuechu.github.io/2018/10/05/oracle%20Stored%20Procedure/"/>
    <id>http://baiyuechu.github.io/2018/10/05/oracle Stored Procedure/</id>
    <published>2018-10-05T14:06:13.394Z</published>
    <updated>2017-05-05T08:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>存储过程（Stored Procedure）：已预编译为一个可执行过程的一个或多个SQL语句。 <a id="more"></a></p><h3 id="创建存储过程语法"><a href="#创建存储过程语法" class="headerlink" title="创建存储过程语法"></a>创建存储过程语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> create or replace procedure 存储过程名 (参数) </span><br><span class="line">    as</span><br><span class="line">    定义变量(包含变量的大小)               </span><br><span class="line">begin</span><br><span class="line">    null;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p>注意事项：<br>    1.存储过程参数不带取值范围，in表示传入，out表示输出<br>    2.变量带取值范围，后面接分号<br>    3.在判断语句前最好先用count（*）函数判断是否存在该条操作记录<br>    4.用select 。。。into。。。给变量赋值<br>    5.在代码中抛异常用 raise+异常名</p><p>存储过程一般配合游标使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存储过程（Stored Procedure）：已预编译为一个可执行过程的一个或多个SQL语句。
    
    </summary>
    
      <category term="oracle" scheme="http://baiyuechu.github.io/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://baiyuechu.github.io/tags/oracle/"/>
    
      <category term="Stored Procedure" scheme="http://baiyuechu.github.io/tags/Stored-Procedure/"/>
    
  </entry>
  
  <entry>
    <title>oracle分页</title>
    <link href="http://baiyuechu.github.io/2018/10/05/oracle%20Paging/"/>
    <id>http://baiyuechu.github.io/2018/10/05/oracle Paging/</id>
    <published>2018-10-05T14:06:13.378Z</published>
    <updated>2017-05-05T08:30:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>ROWNUM只适用于小于或小于等于，如果进行等于判断，那么只能等于1，不能进行大于的比较。<a id="more"></a><br>因为ROWNUM总是从1开始，如果这条记录的值最终满足所有的条件，那么ROWNUM会递加，下一条记录的ROWNUM会返回2，否则下一条记录的ROWNUM仍然返回1。<br>分页查询格式1<br>在查询的最外层控制分页的最小值和最大值。查询语句如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM   </span><br><span class="line">(  </span><br><span class="line">SELECT A.*, ROWNUM RN   </span><br><span class="line">FROM (SELECT * FROM TABLE_NAME) A   </span><br><span class="line">)  </span><br><span class="line">WHERE RN BETWEEN 21 AND 40</span><br></pre></td></tr></table></figure></p><p>分页查询格式2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM   </span><br><span class="line">(  </span><br><span class="line">SELECT A.*, ROWNUM RN   </span><br><span class="line">FROM (SELECT * FROM TABLE_NAME) A   </span><br><span class="line">WHERE ROWNUM &lt;= 40  </span><br><span class="line">)  </span><br><span class="line">WHERE RN &gt;= 21</span><br></pre></td></tr></table></figure></p><p>对比这两种写法，绝大多数的情况下，第2个查询的效率比第1个高得多。<br>这是由于CBO优化模式下，Oracle可以将外层的查询条件推到内层查询中，以提高内层查询的执行效率。对于第2个查询语句，第二层的查询条件WHERE ROWNUM &lt;= 40就可以被Oracle推入到内层查询中，这样Oracle查询的结果一旦超过了ROWNUM限制条件，就终止查询将结果返回了。<br>而第1个查询语句，由于查询条件BETWEEN 21 AND 40是存在于查询的第三层，而Oracle无法将第三层的查询条件推到最内层。因此，对于第1个查询语句，Oracle最内层返回给中间层的是所有满足条件的数据，而中间层返回给最外层的也是所有数据。数据的过滤在最外层完成，显然这个效率要比第2个查询低得多。<br>摘自某博客<a href="http://blog.csdn.net/fw0124/article/details/42737671" target="_blank" rel="noopener">原文链接</a><br>对于第三种，考虑到多表联合的情况，在系统中使用HINT，正在学习中。。。<br><a href="http://czmmiao.iteye.com/blog/1478465" target="_blank" rel="noopener">Hint概述</a><br>oracle实现多表链接分页查询(貌似和单表分页区别不大)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM (</span><br><span class="line">SELECT A.*, ROWNUM RN FROM(</span><br><span class="line">SELECT t.tname, n.title, n.author FROM t_topic t, t_news n</span><br><span class="line">WHERE t.id = n.tid)A</span><br><span class="line">)</span><br><span class="line">WHERE RN BETWEEN 21 AND 40;</span><br></pre></td></tr></table></figure></p><p>附：<a href="http://www.iteye.com/topic/266301" target="_blank" rel="noopener">Hibernate分页查询小结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ROWNUM只适用于小于或小于等于，如果进行等于判断，那么只能等于1，不能进行大于的比较。
    
    </summary>
    
      <category term="oracle" scheme="http://baiyuechu.github.io/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://baiyuechu.github.io/tags/oracle/"/>
    
      <category term="paging" scheme="http://baiyuechu.github.io/tags/paging/"/>
    
  </entry>
  
  <entry>
    <title>oracle索引</title>
    <link href="http://baiyuechu.github.io/2018/10/05/oracle%20Index/"/>
    <id>http://baiyuechu.github.io/2018/10/05/oracle Index/</id>
    <published>2018-10-05T14:06:13.378Z</published>
    <updated>2017-05-11T11:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>索引<br>索引是关系数据库中用于存放每一条记录的一种对象，主要目的是加快数据的读取速度和完整性检查。建立索引是一项技术性要求高的工作。一般在数据库设计阶段的与数据库结构一道考虑。应用系统的性能直接与索引的合理有关。<a id="more"></a></p><h3 id="oracle索引的建立"><a href="#oracle索引的建立" class="headerlink" title="oracle索引的建立"></a>oracle索引的建立</h3><p>语法：CREATE INDEX index ON table (column[, column]…);<br>补充说明：</p><blockquote><p>   1.oracle中的索引是以表的形式存在，Oracle自动使用并维护索引，插入、删除、更新表后，自动更新索引，所以频繁insert和update的字段不适合建立索引。<br>   2.索引需要定期的重建，且一张表的索引最好不要超过5个<br>   3.索引的关键在于通过一组排序后的索引键来取代默认的全表扫描检索方式。索引直接指向包含所查询值的行的位置，减少磁盘I/O，从而提高检索效率<br>   4.索引在逻辑上和物理上都与相关的表和数据无关，当创建或者删除一个索引时，不会影响基本的表<br>   5.当建立Primary Key(主键)或者Unique constraint(唯一约束)时，唯一索引将被自动建立<br>   6.LONG（可变长字符串数据，最长2G）和LONG RAW（可变长二进制数据，最长2G）列不能创建索引<br>   7.使用create index时要将最常查询的列放在最前面<br>   8.经常进行连接查询的列应该创建索引,小表无需建立索引<br>   9.列中有很多空值，但经常查询该列上非空记录时可以建立索引<br>   10.对于基数大的列适合建立B树索引，对于基数小的列适合简历位图索引<br>   11.至少要包含组合索引的第一列（即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引）</p><ol start="12"><li>如果有两个或者以上的索引，其中有一个唯一性索引，而其他是非唯一，这种情况下oracle将使用唯一性索引而完全忽略非唯一性索引</li></ol></blockquote><h3 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h3><p>1.重命名索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index index_sno rename to bitmap_index;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>合并索引（表使用一段时间后在索引中会产生碎片，此时索引效率会降低，可以选择重建索引或者合并索引,合并索引方式更好些，无需额外存储空间，代价较低）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index index_sno coalesce;</span><br></pre></td></tr></table></figure></li></ol><p>3.重建索引</p><p>　　方式一：删除原来的索引，重新建立索引</p><p>　　方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index index_sno rebuild;</span><br></pre></td></tr></table></figure></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_sno;</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from all_indexes where table_name=&apos;student&apos;;</span><br></pre></td></tr></table></figure><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p><a href="http://www.oschina.net/question/30362_4057" target="_blank" rel="noopener">一些oracle索引的说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引&lt;br&gt;索引是关系数据库中用于存放每一条记录的一种对象，主要目的是加快数据的读取速度和完整性检查。建立索引是一项技术性要求高的工作。一般在数据库设计阶段的与数据库结构一道考虑。应用系统的性能直接与索引的合理有关。
    
    </summary>
    
      <category term="oracle" scheme="http://baiyuechu.github.io/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://baiyuechu.github.io/tags/oracle/"/>
    
      <category term="index" scheme="http://baiyuechu.github.io/tags/index/"/>
    
  </entry>
  
  <entry>
    <title>linux安装mysql5.6.39</title>
    <link href="http://baiyuechu.github.io/2018/10/05/linuxMysql/"/>
    <id>http://baiyuechu.github.io/2018/10/05/linuxMysql/</id>
    <published>2018-10-05T14:06:13.363Z</published>
    <updated>2018-03-09T15:05:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>记初次在linux上安装mysql<a id="more"></a></p><p>先去<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">mysql官网地址</a>下载<br><img src="https://baiyuechu.github.io/img/01.png" alt="load..."><br>貌似可以用yum安装，不过全是英文说明我就很蛋疼了。。。。。<br>然后上传到服务器，解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf mysql-5.6.3*****</span><br></pre></td></tr></table></figure></p><p>改名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mysql-5.6.3****** mysql</span><br></pre></td></tr></table></figure></p><p>添加系统mysql组和mysql用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql和useradd mysql -g mysql</span><br></pre></td></tr></table></figure></p><p>关联mysql用户到mysql用户组中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql  /home/mysql/</span><br></pre></td></tr></table></figure></p><p>更改mysql安装文件夹mysql/的权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 mysql</span><br></pre></td></tr></table></figure></p><p>初始化mysql命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqld --user=mysql --basedir=/software/mysql --datadir=/data/mysql --initialize</span><br></pre></td></tr></table></figure></p><p>如果提示文件夹不存在什么的就去创建，然后授权chown -R mysql:mysql XXX<br>如果初始化时报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error while loading shared libraries: libnuma.so.1: cannot open shared objec</span><br></pre></td></tr></table></figure></p><p>是因为libnuma安装的是32位，我们这里需要64位的，执行下面语句就可以解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install numactl.x86_64</span><br></pre></td></tr></table></figure></p><p>执行完后重新初始化mysql命令<br>注意提示，mysql版本不同有不同情况<br>1.[Note] A temporary password is generated for root@localhost: o*s#gqh)F4Ck，已经给你了初始密码<br>2.或者密码为空，他会提示你去设置<br>修改Mysql配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cp /home/mysql/support-files/mysql.server  /etc/init.d/mysqld</span><br><span class="line">chmod 755 /etc/init.d/mysqld</span><br><span class="line">vi /etc/init.d/mysqld</span><br><span class="line">#将下面的地址换成自己的mysql地址</span><br><span class="line">then</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">bindir=/usr/local/mysql/bin</span><br><span class="line">if test -z &quot;$datadir&quot;</span><br><span class="line">then</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line">fi</span><br><span class="line">sbindir=/usr/local/mysql/bin</span><br><span class="line">libexecdir=/usr/local/mysql/bin</span><br><span class="line">else</span><br></pre></td></tr></table></figure></p><p>修改my.cnf文件<br>我的my.cnf文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">no-beep</span><br><span class="line">socket =/software/mysql/mysql.sock</span><br><span class="line"># pipe</span><br><span class="line"># socket=0.0</span><br><span class="line">port=3306</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/software/mysql</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">port=3306</span><br><span class="line">pid-file=/software/mysql/mysqld.pid</span><br><span class="line">#skip-grant-tables</span><br><span class="line">skip-name-resolve</span><br><span class="line">socket = /software/mysql/mysql.sock</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">explicit_defaults_for_timestamp = true</span><br><span class="line"># Server Id.</span><br><span class="line">server-id=1</span><br><span class="line">max_connections=2000</span><br><span class="line">query_cache_size=0</span><br><span class="line">table_open_cache=2000</span><br><span class="line">tmp_table_size=246M</span><br><span class="line">thread_cache_size=300</span><br><span class="line">#限定用于每个数据库线程的栈大小。默认设置足以满足大多数应用</span><br><span class="line">thread_stack = 192k</span><br><span class="line">key_buffer_size=512M</span><br><span class="line">read_buffer_size=4M</span><br><span class="line">read_rnd_buffer_size=32M</span><br><span class="line">innodb_data_home_dir = /data/mysql</span><br><span class="line">innodb_flush_log_at_trx_commit=0</span><br><span class="line">innodb_log_buffer_size=16M</span><br><span class="line">innodb_buffer_pool_size=256M</span><br><span class="line">innodb_log_file_size=128M</span><br><span class="line">innodb_thread_concurrency=128</span><br><span class="line">innodb_autoextend_increment=1000</span><br><span class="line">innodb_buffer_pool_instances=8</span><br><span class="line">innodb_concurrency_tickets=5000</span><br><span class="line">innodb_old_blocks_time=1000</span><br><span class="line">innodb_open_files=300</span><br><span class="line">innodb_stats_on_metadata=0</span><br><span class="line">innodb_file_per_table=1</span><br><span class="line">innodb_checksum_algorithm=0</span><br><span class="line">back_log=80</span><br><span class="line">flush_time=0</span><br><span class="line">join_buffer_size=128M</span><br><span class="line">max_allowed_packet=1024M</span><br><span class="line">max_connect_errors=2000</span><br><span class="line">open_files_limit=4161</span><br><span class="line">query_cache_type=0</span><br><span class="line">sort_buffer_size=32M</span><br><span class="line">table_definition_cache=1400</span><br><span class="line">binlog_row_event_max_size=8K</span><br><span class="line">sync_master_info=10000</span><br><span class="line">sync_relay_log=10000</span><br><span class="line">sync_relay_log_info=10000</span><br><span class="line">#批量插入数据缓存大小，可以有效提高插入效率，默认为8M</span><br><span class="line">bulk_insert_buffer_size = 64M</span><br><span class="line">interactive_timeout = 120</span><br><span class="line">wait_timeout = 120</span><br><span class="line">log-bin-trust-function-creators=1</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># include all files from the config directory</span><br><span class="line">#</span><br><span class="line">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure></p><p>启动mysql<br>/etc/init.d/mysqld start<br>登录mysql<br>mysql/bin/mysql -u root –p</p><p>可参考<a href="https://www.cnblogs.com/shizhongyang/p/8464876.html（本文多转自此博客），https://www.cnblogs.com/xinjing-jingxin/p/8025805.html" target="_blank" rel="noopener">https://www.cnblogs.com/shizhongyang/p/8464876.html（本文多转自此博客），https://www.cnblogs.com/xinjing-jingxin/p/8025805.html</a><br>此告一段，现在说说让mysql能够被远程访问</p><p>首先防火墙开放3306<br>iptables -I INPUT -p tcp –dport 3306 -j ACCEPT<br>重启iptables<br>然后让mysql允许所有ip访问他<br>查看3306端口状态 netstat -ntpl |grep 3306<br>tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      9629/mysqld<br>如果前面显示tcp6，说明3306端口被绑定在本地，只能本地访问<br>看网上说在/etc/my.cnf文件中注释掉这个就行bind-address=127.0.0.1  可我这个文件中没有这个配置，=_=!<br>然后我加上这个配置允许所有IP，就行了O。O<br>bind-address=0.0.0.0<br>最后，如果是云服务器的话，记得在安全组内开放3306哦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记初次在linux上安装mysql
    
    </summary>
    
      <category term="linux" scheme="http://baiyuechu.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://baiyuechu.github.io/tags/linux/"/>
    
      <category term="mysql" scheme="http://baiyuechu.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java单例模式</title>
    <link href="http://baiyuechu.github.io/2018/10/05/javaSingleton/"/>
    <id>http://baiyuechu.github.io/2018/10/05/javaSingleton/</id>
    <published>2018-10-05T14:06:13.363Z</published>
    <updated>2017-05-17T00:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在GoF的23种设计模式中，单例模式是比较简单的一种。然而，有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。<a id="more"></a></p><p><a href="http://devbean.blog.51cto.com/448512/203501/" target="_blank" rel="noopener">原文链接</a><br>所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。</p><h3 id="最简单的实现"><a href="#最简单的实现" class="headerlink" title="最简单的实现"></a>最简单的实现</h3><p>首先，能够想到的最简单的实现是，把类的构造函数写成private的，从而保证别的类不能实例化此类，然后在类中提供一个静态的实例并能够返回给使用者。这样，使用者就可以通过这个引用使用到这个类的实例了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line"></span><br><span class="line">  private static final SingletonClass instance = new SingletonClass(); </span><br><span class="line">    </span><br><span class="line">  public static SingletonClass getInstance() &#123; </span><br><span class="line">    return instance; </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line">     </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上例，外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。</p><h3 id="性能优化——lazy-loaded"><a href="#性能优化——lazy-loaded" class="headerlink" title="性能优化——lazy loaded"></a>性能优化——lazy loaded</h3><p>上面的代码虽然简单，但是有一个问题——无论这个类是否被使用，都会创建一个instance对象。如果这个创建过程很耗时，比如需要连接10000次数据库(夸张了…:-))，并且这个类还并不一定会被使用，那么这个创建过程就是无用的。怎么办呢？</p><p>为了解决这个问题，我们想到了新的解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line"></span><br><span class="line">  private static SingletonClass instance = null; </span><br><span class="line">    </span><br><span class="line">  public static SingletonClass getInstance() &#123; </span><br><span class="line">    if(instance == null) &#123; </span><br><span class="line">      instance = new SingletonClass(); </span><br><span class="line">    &#125; </span><br><span class="line">    return instance; </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line">     </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码的变化有两处——首先，把instance初始化为null，直到第一次使用的时候通过判断是否为null来创建对象。因为创建过程不在声明处，所以那个final的修饰必须去掉。</p><p>我们来想象一下这个过程。要使用SingletonClass，调用getInstance()方法。第一次的时候发现instance是null，然后就新建一个对象，返回出去；第二次再使用的时候，因为这个instance是static的，所以已经不是null了，因此不会再创建对象，直接将其返回。</p><p>这个过程就成为lazy loaded，也就是迟加载——直到使用的时候才进行加载。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>上面的代码很清楚，也很简单。然而就像那句名言：“80%的错误都是由20%代码优化引起的”。单线程下，这段代码没有什么问题，可是如果是多线程，麻烦就来了。我们来分析一下：</p><p>线程A希望使用SingletonClass，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换，线程B开始执行，它要使用SingletonClass，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个SingletonClass的对象——单例失败！</p><p>解决的方法也很简单，那就是加锁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line"></span><br><span class="line">  private static SingletonClass instance = null; </span><br><span class="line">    </span><br><span class="line">  public synchronized static SingletonClass getInstance() &#123; </span><br><span class="line">    if(instance == null) &#123; </span><br><span class="line">      instance = new SingletonClass(); </span><br><span class="line">    &#125; </span><br><span class="line">    return instance; </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line">     </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是要getInstance()加上同步锁，一个线程必须等待另外一个线程创建完成后才能使用这个方法，这就保证了单例的唯一性。</p><h3 id="又是性能"><a href="#又是性能" class="headerlink" title="又是性能"></a>又是性能</h3><p>上面的代码又是很清楚很简单的，然而，简单的东西往往不够理想。这段代码毫无疑问存在性能的问题——synchronized修饰的同步块可是要比一般的代码段慢上几倍的！如果存在很多次getInstance()的调用，那性能问题就不得不考虑了！</p><p>让我们来分析一下，究竟是整个方法都必须加锁，还是仅仅其中某一句加锁就足够了？我们为什么要加锁呢？分析一下出现lazy loaded的那种情形的原因。原因就是检测null的操作和创建对象的操作分离了。如果这两个操作能够原子地进行，那么单例就已经保证了。于是，我们开始修改代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line"></span><br><span class="line">  private static SingletonClass instance = null; </span><br><span class="line">    </span><br><span class="line">  public static SingletonClass getInstance() &#123; </span><br><span class="line">    synchronized (SingletonClass.class) &#123; </span><br><span class="line">      if(instance == null) &#123; </span><br><span class="line">        instance = new SingletonClass(); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125;     </span><br><span class="line">    return instance; </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line">     </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先去掉getInstance()的同步操作，然后把同步锁加载if语句上。但是这样的修改起不到任何作用：因为每次调用getInstance()的时候必然要同步，性能问题还是存在。如果……如果我们事先判断一下是不是为null再去同步呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line"></span><br><span class="line">  private static SingletonClass instance = null; </span><br><span class="line"></span><br><span class="line">  public static SingletonClass getInstance() &#123; </span><br><span class="line">    if (instance == null) &#123; </span><br><span class="line">      synchronized (SingletonClass.class) &#123; </span><br><span class="line">        if (instance == null) &#123; </span><br><span class="line">          instance = new SingletonClass(); </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return instance; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有问题吗？首先判断instance是不是为null，如果为null，加锁初始化；如果不为null，直接返回instance。</p><p>这就是double-checked locking设计实现单例模式。到此为止，一切都很完美。我们用一种很聪明的方式实现了单例模式。</p><h3 id="从源头检查"><a href="#从源头检查" class="headerlink" title="从源头检查"></a>从源头检查</h3><p>下面我们开始说编译原理。所谓编译，就是把源代码“翻译”成目标代码——大多数是指机器代码——的过程。针对Java，它的目标代码不是本地机器代码，而是虚拟机代码。编译原理里面有一个很重要的内容是编译器优化。所谓编译器优化是指，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。这个过程成为reorder。</p><p>要知道，JVM只是一个标准，并不是实现。JVM中并没有规定有关编译器优化的内容，也就是说，JVM实现可以自由的进行编译器优化。</p><p>下面来想一下，创建一个变量需要哪些步骤呢？一个是申请一块内存，调用构造方法进行初始化操作，另一个是分配一个指针指向这块内存。这两个操作谁在前谁在后呢？JVM规范并没有规定。那么就存在这么一种情况，JVM是先开辟出一块内存，然后把指针指向这块内存，最后调用构造方法进行初始化。</p><p>下面我们来考虑这么一种情况：线程A开始创建SingletonClass的实例，此时线程B调用了getInstance()方法，首先判断instance是否为null。按照我们上面所说的内存模型，A已经把instance指向了那块内存，只是还没有调用构造方法，因此B检测到instance不为null，于是直接把instance返回了——问题出现了，尽管instance不为null，但它并没有构造完成，就像一套房子已经给了你钥匙，但你并不能住进去，因为里面还没有收拾。此时，如果B在A将instance构造完成之前就是用了这个实例，程序就会出现错误了！</p><p>于是，我们想到了下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line"></span><br><span class="line">  private static SingletonClass instance = null; </span><br><span class="line"></span><br><span class="line">  public static SingletonClass getInstance() &#123; </span><br><span class="line">    if (instance == null) &#123; </span><br><span class="line">      SingletonClass sc; </span><br><span class="line">      synchronized (SingletonClass.class) &#123; </span><br><span class="line">        sc = instance; </span><br><span class="line">        if (sc == null) &#123; </span><br><span class="line">          synchronized (SingletonClass.class) &#123; </span><br><span class="line">            if(sc == null) &#123; </span><br><span class="line">              sc = new SingletonClass(); </span><br><span class="line">            &#125; </span><br><span class="line">          &#125; </span><br><span class="line">          instance = sc; </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return instance; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在第一个同步块里面创建一个临时变量，然后使用这个临时变量进行对象的创建，并且在最后把instance指针临时变量的内存空间。写出这种代码基于以下思想，即synchronized会起到一个代码屏蔽的作用，同步块里面的代码和外部的代码没有联系。因此，在外部的同步块里面对临时变量sc进行操作并不影响instance，所以外部类在instance=sc;之前检测instance的时候，结果instance依然是null。</p><p>不过，这种想法完全是错误的！同步块的释放保证在此之前——也就是同步块里面——的操作必须完成，但是并不保证同步块之后的操作不能因编译器优化而调换到同步块结束之前进行。因此，编译器完全可以把instance=sc;这句移到内部同步块里面执行。这样，程序又是错误的了！</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>说了这么多，难道单例没有办法在Java中实现吗？其实不然！</p><p>在JDK 5之后，Java使用了新的内存模型。volatile关键字有了明确的语义——在JDK1.5之前，volatile是个关键字，但是并没有明确的规定其用途——被volatile修饰的写变量不能和之前的读写代码调整，读变量不能和之后的读写代码调整！因此，只要我们简单的把instance加上volatile关键字就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line"></span><br><span class="line">  private volatile static SingletonClass instance = null; </span><br><span class="line"></span><br><span class="line">  public static SingletonClass getInstance() &#123; </span><br><span class="line">    if (instance == null) &#123; </span><br><span class="line">      synchronized (SingletonClass.class) &#123; </span><br><span class="line">        if(instance == null) &#123; </span><br><span class="line">          instance = new SingletonClass(); </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return instance; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，这只是JDK1.5之后的Java的解决方案，那之前版本呢？其实，还有另外的一种解决方案，并不会受到Java版本的影响：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonClass &#123; </span><br><span class="line">    </span><br><span class="line">  private static class SingletonClassInstance &#123; </span><br><span class="line">    private static final SingletonClass instance = new SingletonClass(); </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  public static SingletonClass getInstance() &#123; </span><br><span class="line">    return SingletonClassInstance.instance; </span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  private SingletonClass() &#123; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这一版本的单例模式实现代码中，我们使用了Java的静态内部类。这一技术是被JVM明确说明了的，因此不存在任何二义性。在这段代码中，因为SingletonClass没有static的属性，因此并不会被初始化。直到调用getInstance()的时候，会首先加载SingletonClassInstance类，这个类有一个static的SingletonClass实例，因此需要调用SingletonClass的构造方法，然后getInstance()将把这个内部类的instance返回给使用者。由于这个instance是static的，因此并不会构造多次。</p><p>由于SingletonClassInstance是私有静态内部类，所以不会被其他类知道，同样，static语义也要求不会有多个实例存在。并且，JSL规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是并发的，所以getInstance()也并不需要加同步。</p><p>至此，我们完整的了解了单例模式在Java语言中的时候，提出了两种解决方案。个人偏向于第二种，并且Effiective Java也推荐的这种方式。</p><p>另：介绍一种用枚举实现的单例，枚举用的人不多，可能是因为他的扩展性不够好，但是这种方式可以防止利用反射来破坏单例</p><p>枚举<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在GoF的23种设计模式中，单例模式是比较简单的一种。然而，有时候越是简单的东西越容易出现问题。下面就单例设计模式详细的探讨一下。
    
    </summary>
    
      <category term="java" scheme="http://baiyuechu.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://baiyuechu.github.io/tags/java/"/>
    
      <category term="singleton" scheme="http://baiyuechu.github.io/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>java适配器模式，装饰器模式，代理模式比较</title>
    <link href="http://baiyuechu.github.io/2018/10/05/javaMode/"/>
    <id>http://baiyuechu.github.io/2018/10/05/javaMode/</id>
    <published>2018-10-05T14:06:13.347Z</published>
    <updated>2017-05-11T14:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式，其实是一种解决方法，Java作为一种面向对象的语言，对于所有的设计模式在实现上，总是少不了对接口的实现，对抽象类的继承，有时候似乎是为了去实现接口而去写接口，所以在这三种模式的说明代码中，我们都定义了接口这些东西，所以才有了现在的混淆。<a id="more"></a></p><p>先不厌其烦的介绍下这三种的设计模式的概念吧。</p><p>适配器模式，一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</p><p>装饰器模式，原有的不能满足现有的需求，对原有的进行增强。</p><p>代理模式，同一个类而去调用另一个类的方法，不对这个方法进行直接操作。</p><p>适配器的特点在于兼容，从代码上的特点来说，适配类与原有的类具有相同的接口，并且持有新的目标对象。</p><p>就如同一个三孔转2孔的适配器一样，他有三孔的插头，可以插到三孔插座里，又有两孔的插座可以被2孔插头插入。</p><p>适配器模式是在于对原有3孔的改造。</p><p>在使用适配器模式的时候，我们必须同时持有原对象，适配对象，目标对象。。。。</p><p>装饰器模式特点在于增强，他的特点是被装饰类和所有的装饰类必须实现同一个接口，而且必须持有被装饰的对象，可以无限装饰。</p><p>代理模式的特点在于隔离，隔离调用类和被调用类的关系，通过一个代理类去调用。</p><p>总的来说就是如下三句话：</p><p> 1 适配器模式是将一个类(a)通过某种方式转换成另一个类(b).<br> 2 装饰模式是在一个原有类(a)的基础之上增加了某些新的功能变成另一个类(b).<br> 3 代理模式是将一个类(a)转换成具体的操作类(b).</p><p>又是罗里吧嗦一大段话，然后我们开心的来到了举例时间，这次举的是工作中实际的例子。</p><p>先简单介绍一下，公司有一个ORDER系统，专门用于提供订单管理的接口，提供给O2O商城，WAP商城，手机类APP，微信等客户端调用。</p><p>ORDER系统在上线之时，已经包含了非常完整的数据操作。</p><p>现手机类APP需要升级，老的接口可能不能满足需求，如原O2O订单提货延长有效期接口需要提供截至时间和订单号，新APP可能不提供截至时间，只需要 提供订单号即可延长时间。</p><p>而老的接口又不能修改，因为老的order接口是针对所有平台的，那么必须将新接口要求与原接口进行适配。。。</p><p>解决方案如下：新增AppAdepter类，用来适配老的接口，同时开发给新的接口。。。。</p><p>先给出原接口和实现类</p><p>原接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 原接口，需要传入orderId，时间 </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">public interface SourceOrderApi &#123;  </span><br><span class="line">    public void updateDate(String orderId,String date,String client);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line"></span><br><span class="line">public class SourceOrderApiImpl implements SourceOrderApi&#123;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void updateDate(String orderId, String date, String client) &#123;  </span><br><span class="line">        System.out.println(client+&quot;已将订单&quot;+orderId+&quot;的有效期延长至&quot;+date);         </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这套代码中，对于客户端来说需要传入orderId  和  有效期date 和客户端名字才能延长。。。</p><p>Main方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        SourceOrderApi sourceOrderApi = new SourceOrderApiImpl();  </span><br><span class="line">        sourceOrderApi.updateDate(&quot;123456&quot;, &quot;2014-10-15&quot;, &quot;user&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p>而对于新的接口，客户端则不必去传入date 参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface AppOrderApi &#123;  </span><br><span class="line">    //只需要传入订单Id即可  </span><br><span class="line">    public void updateDate(String orderId,String client);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新的实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class AppOrderApiImpl implements AppOrderApi&#123;  </span><br><span class="line">      </span><br><span class="line">    SourceOrderApi sourceOrderApi;  </span><br><span class="line">      </span><br><span class="line">    public AppOrderApiImpl()&#123;  </span><br><span class="line">        sourceOrderApi = new SourceOrderApiImpl();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void updateDate(String orderId,String client) &#123;  </span><br><span class="line">        //这里适配的方式随意，但是保证是要完全兼容原有的，就是保证调用原有的接口  </span><br><span class="line">        sourceOrderApi.updateDate(orderId, &quot;9999-12-31&quot;,client);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        AppOrderApi appOrderApi = new AppOrderApiImpl();  </span><br><span class="line">        appOrderApi.updateDate(&quot;123456&quot;, &quot;user&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这套代码中，新的实现类持有了老接口的对象，就是把这个对象new 出来。。。<br>然后在新的方法里，进行适配操作。</p><p>而这里所谓的适配就是兼容老接口和兼容新接口。</p><p>兼容老接口非常简单，就是直接调用老的方法即可。</p><p>而兼容新接口就是你所要去做的业务逻辑。。。</p><p>比如我这里做了比较简单的操作，app类的统一传入“9999-12-31”，这些都是根据具体的项目需求去实现你的业务代码。</p><p>看到这，很多人会觉得 这样的代码是不是很常见。。。。</p><p>我自己都特意去翻了一下我之前的代码，很多类似的写法。。。</p><p>其实设计模式很多时候都融入到我们的代码中，只是我们没有去理解这种模式，所以就算你自己写出来了，都不知道这是一种适配器模式。。。</p><p>设计模式是一种思想，他没有固定的实现代码，我大量查阅了很多大神的的适配器模式解释，大家都不约而同的提到了类的适配和对象的适配，代码中有实现继承这样的写法。当然了，这些大神的写法都是比较标准的。。。</p><p>但是仔细再回看下GOF的适配器模式解释。</p><p>只需要将原接口转化为客户希望的另一个接口，就是适配器模式！</p><p>转化无非就是1.继承原类或者实现原接口  2.持有原接口的对象 </p><p>再实现目标接口。。。。</p><p>那么第一种就是类的适配，第二种就是对象的适配！仅此而已。。。。</p><p>那么再回头来说代理模式，在代码上，和适配器模式有着相似的地方！</p><p>再比如，现在我们公司的系统又要进行升级，我们原先的接口没有加入安全机制，导致了任何人都可以随意调用这个接口，现在公司需要对这个接口进行改造，只其只能被admin这个客户端调用，其他用户一律要输入账号密码才能调用</p><p>那么上面原接口和类不需要改动，我们只需要新增代理器即可。。。</p><p>这里就会显出代理模式和适配器模式最大的区别，代理模式是与原对象实现同一个接口，而适配器类则是匹配新接口，说白了，实现一个新的接口。</p><p>代理类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ProxySourceOrderApiImpl implements SourceOrderApi &#123;  </span><br><span class="line">    SourceOrderApi sourceOrderApiImpl;  </span><br><span class="line">    public ProxySourceOrderApiImpl()&#123;  </span><br><span class="line">        sourceOrderApiImpl = new SourceOrderApiImpl();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void updateDate(String orderId, String date, String client) &#123;  </span><br><span class="line">        //进行判断，如果是admin则更新否则让其输入账号密码  </span><br><span class="line">        if(&quot;admin&quot;.equals(client))&#123;  </span><br><span class="line">            sourceOrderApiImpl.updateDate(orderId, date, client);  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            System.out.println(&quot;账号不是admin，没有查询权限，请输入以admin操作&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        SourceOrderApi proxySourceOrderApiImpl = new ProxySourceOrderApiImpl();  </span><br><span class="line">        proxySourceOrderApiImpl.updateDate(&quot;123456&quot;, &quot;2014-10-15&quot;, &quot;user&quot;);  </span><br><span class="line">        proxySourceOrderApiImpl.updateDate(&quot;123456&quot;, &quot;2014-10-15&quot;, &quot;admin&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p>这里的代理类必须要持要实现原接口和持有原接口的对象，才能称之为代理类。</p><p>这样，我们不需要修改原先的实现类，用一个代理类来进行过滤。有些人可能有这样的疑惑，为什么不直接在原实现类中修改，记住JAVA设计模式的基本原则，对内关闭修改。</p><p>假如你并没有对方的类，别人只是提供给你这样一个可以操作的JAR包你如何去做？把JAR包反编译，再修改？又假如某些地方可以直接调用原有接口，你如果修改原有的实现类，岂不是对其他的地方也造成了影响？不能修改原有代码这是基本原则。</p><p>最后，就是装饰器模式，装饰器模式与相对于上面2种模式更好理解，差别也最大。</p><p>假如说，现在这个延长订单，不光可以延长订单提货有效期，可以延长订单的退货有效期。</p><p>这就是一个典型的装饰器，你需要做的是丰富原接口的功能，并且不改动原先的接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class NewSourceOrderApiImpl implements SourceOrderApi &#123;  </span><br><span class="line">  </span><br><span class="line">    SourceOrderApi sourceOrderApi;  </span><br><span class="line">    public NewSourceOrderApiImpl(SourceOrderApi sourceOrderApi)&#123;  </span><br><span class="line">        this.sourceOrderApi = sourceOrderApi;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void updateDate(String orderId, String date, String client) &#123;  </span><br><span class="line">        sourceOrderApi.updateDate(orderId, date, client);  </span><br><span class="line">        System.out.println(client+&quot;已将订单&quot;+orderId+&quot;的退款期延长至&quot;+date);         </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        SourceOrderApi sourceOrderApi = new NewSourceOrderApiImpl(new SourceOrderApiImpl());  </span><br><span class="line">        sourceOrderApi.updateDate(&quot;123456&quot;, &quot;2014-10-15&quot;, &quot;user&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在装饰器模式中，必须要有被装饰的类和装饰的类。。在这套代码中，原先SourceOrderApi的对象就是被装饰的类，而新建NewSourceOrderApiImpl 就是装饰类，装饰类必须把被装饰的对象当作参数传入。</p><p>这就是和代理模式的代码不同之处，代理模式一定是自身持有这个对象，不需要从外部传入。而装饰模式的一定是从外部传入，并且可以没有顺序，按照代码的实际需求随意挑换顺序，就如你吃火锅先放白菜还是先放丸子都可以。</p><p>再从使用上来看，代理模式注重的是隔离限制，让外部不能访问你实际的调用对象，比如权限控制，装饰模式注重的是功能的拓展，在同一个方法下实现更多的功能。</p><p><a href="http://blog.csdn.net/lulei9876/article/details/39994825" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式，其实是一种解决方法，Java作为一种面向对象的语言，对于所有的设计模式在实现上，总是少不了对接口的实现，对抽象类的继承，有时候似乎是为了去实现接口而去写接口，所以在这三种模式的说明代码中，我们都定义了接口这些东西，所以才有了现在的混淆。
    
    </summary>
    
      <category term="java" scheme="http://baiyuechu.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://baiyuechu.github.io/tags/java/"/>
    
      <category term="mode" scheme="http://baiyuechu.github.io/tags/mode/"/>
    
  </entry>
  
  <entry>
    <title>java登录相关</title>
    <link href="http://baiyuechu.github.io/2018/10/05/javaLogin/"/>
    <id>http://baiyuechu.github.io/2018/10/05/javaLogin/</id>
    <published>2018-10-05T14:06:13.347Z</published>
    <updated>2017-05-17T00:44:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载一篇关于检验用户是否登录及自动登录的博客<a id="more"></a></p><h3 id="验证用户是否已经登录"><a href="#验证用户是否已经登录" class="headerlink" title="验证用户是否已经登录"></a>验证用户是否已经登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package cn.hongxin.filter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class LoginFilter implements Filter&#123;</span><br><span class="line"></span><br><span class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void doFilter(ServletRequest request, ServletResponse response,</span><br><span class="line"></span><br><span class="line">      FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    //将request强转成htt...</span><br><span class="line"></span><br><span class="line">    HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line"></span><br><span class="line">    //获取session</span><br><span class="line"></span><br><span class="line">    HttpSession ss = req.getSession();</span><br><span class="line"></span><br><span class="line">    //从session中获取user</span><br><span class="line"></span><br><span class="line">    if(ss.getAttribute(&quot;user&quot;)==null)&#123;</span><br><span class="line"></span><br><span class="line">      System.err.println(&quot;你还没有登录&quot;);</span><br><span class="line"></span><br><span class="line">      req.getSession().setAttribute(&quot;msg&quot;, &quot;请你先登录&quot;);</span><br><span class="line"></span><br><span class="line">      //重定向到登录</span><br><span class="line"></span><br><span class="line">      HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line"></span><br><span class="line">      resp.sendRedirect(req.getContextPath()+&quot;/index.jsp&quot;);[W2] </span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">      //放行</span><br><span class="line"></span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置到web.xml中且对jsps/*进行过虑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">  &lt;filter-name&gt;login&lt;/filter-name&gt;</span><br><span class="line">  &lt;filter-class&gt;cn.itcast.filter.LoginFilter&lt;/filter-class&gt;</span><br><span class="line"> &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line"> &lt;filter-mapping&gt;</span><br><span class="line">  &lt;filter-name&gt;login&lt;/filter-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/jsps/*&lt;/url-pattern&gt;</span><br><span class="line">  &lt;url-pattern&gt;/views/*&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p><h3 id="实现自动登录"><a href="#实现自动登录" class="headerlink" title="实现自动登录"></a>实现自动登录</h3><p>自动登录，是为了帮助用户多次使用这个网页时，不用再次输入用户名和密码就可以登录。</p><p>是指用户将用户的登录信息，人，保存到本地的文件中Cookie中。</p><p> Name,value – 声明时 new Cookie(key,value);</p><p> Path        - 默认值，即为当前保存cookie的这个serlvet所在的路径。</p><p>如果Cookie在这样的路径：<a href="http://loclhost:8080/project/abc/AServlet，则Cookie的路径为" target="_blank" rel="noopener">http://loclhost:8080/project/abc/AServlet，则Cookie的路径为</a>: <a href="http://loclhost/project/abc" target="_blank" rel="noopener">http://loclhost/project/abc</a></p><p> 则说明：</p><p>所在在<a href="http://loclhost/project/abc目录下的servlet才可以读取这个cookie的值。" target="_blank" rel="noopener">http://loclhost/project/abc目录下的servlet才可以读取这个cookie的值。</a></p><p>如果：</p><p>保存Cookie类：<a href="http://loclhost:8080/project/a/b/AServlet，则Cookie的默认path为；http://loclhost/project/a/b" target="_blank" rel="noopener">http://loclhost:8080/project/a/b/AServlet，则Cookie的默认path为；http://loclhost/project/a/b</a></p><p>第一步：开发一个登录页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line"></span><br><span class="line">  &lt;c:when test=&quot;$&#123;empty sessionScope.name&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form name=&quot;x&quot; method=&quot;post&quot; action=&quot;&lt;c:url value=&apos;/LoginServlet&apos;/&gt;&quot;&gt;</span><br><span class="line"></span><br><span class="line">      Name:&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">      auto:</span><br><span class="line"></span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;auto&quot; value=&quot;-1&quot;&gt;不自动登录</span><br><span class="line"></span><br><span class="line">      &lt;br/&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;auto&quot; value=&quot;1&quot;&gt;1天&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input type=&quot;radio&quot; name=&quot;auto&quot; value=&quot;7&quot;&gt;1周&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">      &lt;input type=&quot;submit&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/c:when&gt;</span><br><span class="line"></span><br><span class="line">  &lt;c:otherwise&gt;</span><br><span class="line"></span><br><span class="line">    你已经登录了:$&#123;name&#125;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;a href=&quot;&lt;c:url value=&apos;/LoginServlet&apos;/&gt;&quot;&gt;退出&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/c:otherwise&gt;</span><br><span class="line"></span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><p>第二步：成功保存cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"></span><br><span class="line">    throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">  //接收用户姓名</span><br><span class="line"></span><br><span class="line">  String name = request.getParameter(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">  String auto = request.getParameter(&quot;auto&quot;);</span><br><span class="line"></span><br><span class="line">  //将用户信息放到session</span><br><span class="line"></span><br><span class="line">  request.getSession().setAttribute(&quot;name&quot;,name);</span><br><span class="line"></span><br><span class="line">  //判断auto是否是-1</span><br><span class="line"></span><br><span class="line">  if(!auto.equals(&quot;-1&quot;))&#123;</span><br><span class="line"></span><br><span class="line">    int day = Integer.parseInt(auto);//1|7</span><br><span class="line"></span><br><span class="line">    int seconds = 60*60*24*day;</span><br><span class="line"></span><br><span class="line">    //声明cookie</span><br><span class="line"></span><br><span class="line">    Cookie c = new Cookie(&quot;autoLogin&quot;,name);</span><br><span class="line"></span><br><span class="line">    c.setMaxAge(seconds);</span><br><span class="line"></span><br><span class="line">    c.setPath(request.getContextPath());</span><br><span class="line"></span><br><span class="line">    //保存cookie</span><br><span class="line"></span><br><span class="line">    response.addCookie(c);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：要求访问本网点中任何一个页面都应该实现自动登录</p><p>写一个过虑器，对所有url=/*进行过虑。在doFilter中读取所有cookie。是否存在名称为autoLogin的名称cookie。</p><p>永远都放行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest request, ServletResponse response,</span><br><span class="line"></span><br><span class="line">      FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    //在这儿读取cookie</span><br><span class="line"></span><br><span class="line">    HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line"></span><br><span class="line">    //获取所的有cookie</span><br><span class="line"></span><br><span class="line">    Cookie[] cs = req.getCookies();</span><br><span class="line"></span><br><span class="line">    if(cs!=null)&#123;</span><br><span class="line"></span><br><span class="line">      for(Cookie c:cs)&#123;</span><br><span class="line"></span><br><span class="line">       if(c.getName().equals(&quot;autoLogin&quot;))&#123;//如果存在自动登录的cookie</span><br><span class="line"></span><br><span class="line">         String value = c.getValue();//用户名称</span><br><span class="line"></span><br><span class="line">         //登录成功是指</span><br><span class="line"></span><br><span class="line">         req.getSession().setAttribute(&quot;name&quot;, value);</span><br><span class="line"></span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //不管是否自动登录成</span><br><span class="line"></span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第四涉：配置到web.xml中对所有url=/*<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line"></span><br><span class="line">  &lt;filter-name&gt;auto&lt;/filter-name&gt;</span><br><span class="line"></span><br><span class="line">  &lt;filter-class&gt;cn.itcast.filter.AutoFilter&lt;/filter-class&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line"> &lt;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line">  &lt;filter-name&gt;auto&lt;/filter-name&gt;</span><br><span class="line"></span><br><span class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></p><p> 第五步：开发退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">System.err.println(&quot;用户退出&quot;);</span><br><span class="line"></span><br><span class="line">    //删除整个session</span><br><span class="line"></span><br><span class="line">    request.getSession().invalidate();</span><br><span class="line"></span><br><span class="line">    Cookie c = new Cookie(&quot;autoLogin&quot;, &quot;ddd&quot;);</span><br><span class="line"></span><br><span class="line">    c.setMaxAge(0);</span><br><span class="line"></span><br><span class="line">    c.setPath(request.getContextPath());</span><br><span class="line"></span><br><span class="line">    response.addCookie(c);</span><br><span class="line"></span><br><span class="line">//   request.getSession().removeAttribute(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">    response.sendRedirect(request.getContextPath()+&quot;/index.jsp&quot;);</span><br></pre></td></tr></table></figure></p><p>第六步：优化代码</p><pre><code>由于用户在做手工登录时，也会进入AutoFiilter的doFilter方法，且读取所有Cookie遍历一次。而这次遍历对用户来说是多余。所以应该将LoginServet这个url在doFiler中不过过虑。且对退出也不能自动登录。</code></pre><p><a href="http://www.jb51.net/article/82538.htm" target="_blank" rel="noopener">原文链接</a></p><p><a href="http://www.tuicool.com/articles/uyiiI3" target="_blank" rel="noopener">另一个登录注册系统</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载一篇关于检验用户是否登录及自动登录的博客
    
    </summary>
    
      <category term="java" scheme="http://baiyuechu.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://baiyuechu.github.io/tags/java/"/>
    
      <category term="login" scheme="http://baiyuechu.github.io/tags/login/"/>
    
  </entry>
  
  <entry>
    <title>java验证码</title>
    <link href="http://baiyuechu.github.io/2018/10/05/javaIdentity/"/>
    <id>http://baiyuechu.github.io/2018/10/05/javaIdentity/</id>
    <published>2018-10-05T14:06:13.206Z</published>
    <updated>2017-05-17T00:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是验证码及它的作用<br>    验证码为全自动区分计算机和人类的图灵测试的缩写,是一种区分用户是计算机的公共全自动程序,这个问题可以由计算机生成并评判,但是必须只有人类才能解答.可以防止恶意破解密码、刷票、论坛灌水、有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录。<a id="more"></a></p><h3 id="图文验证码的原理"><a href="#图文验证码的原理" class="headerlink" title="图文验证码的原理"></a>图文验证码的原理</h3><pre><code>在servlet中随机生成一个指定位置的验证码,一般为四位,然后把该验证码保存到session中.在通过Java的绘图类以图片的形式输出该验证码。为了增加验证码的安全级别,可以输出图片的同时输出干扰线,最后在用户提交数据的时候,在服务器端将用户提交的验证码和Session保存的验证码进行比较。</code></pre><h3 id="验证码所需的技术"><a href="#验证码所需的技术" class="headerlink" title="验证码所需的技术"></a>验证码所需的技术</h3><pre><code>i.因为验证码中的文字,数字,应为都是可变的,故要用到随机生成数技术。   ii.如果验证码中包含汉字,则要用到汉字生成技术.   iii.可以使用Ajax技术实现局部刷新   iv.可以使用图片的缩放和旋转技术,   vi.随机绘制干扰线(可以是折现,直线等)   vii.如果考虑到验证码的安全性,可以使用MD5加密.</code></pre><p>验证码模块实例</p><p>1.编写生成英文,数字,汉字随机生成的Servlet类.源代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">package com.servlet;  </span><br><span class="line">  </span><br><span class="line">import java.awt.*;  </span><br><span class="line">import java.awt.geom.*;  </span><br><span class="line">import java.awt.image.*;  </span><br><span class="line">import java.io.*;  </span><br><span class="line">import java.util.*;  </span><br><span class="line">  </span><br><span class="line">import javax.servlet.ServletException;  </span><br><span class="line">import javax.servlet.http.HttpServlet;  </span><br><span class="line">import javax.servlet.http.HttpServletRequest;  </span><br><span class="line">import javax.servlet.http.HttpServletResponse;  </span><br><span class="line">import javax.servlet.http.HttpSession;  </span><br><span class="line">import javax.imageio.ImageIO;  </span><br><span class="line">  </span><br><span class="line">public class PictureCheckCode extends HttpServlet &#123;  </span><br><span class="line">  </span><br><span class="line">    private static final long serialVersionUID = 1L;  </span><br><span class="line">  </span><br><span class="line">    public PictureCheckCode() &#123;  </span><br><span class="line">        super();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void destroy() &#123;  </span><br><span class="line">        super.destroy();   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void init() throws ServletException &#123;  </span><br><span class="line">        super.init();  </span><br><span class="line">    &#125;  </span><br><span class="line">    /*该方法主要作用是获得随机生成的颜色*/   </span><br><span class="line">    public Color getRandColor(int s,int e)&#123;  </span><br><span class="line">        Random random=new Random ();  </span><br><span class="line">        if(s&gt;255) s=255;  </span><br><span class="line">        if(e&gt;255) e=255;  </span><br><span class="line">        int r,g,b;  </span><br><span class="line">        r=s+random.nextInt(e-s);    //随机生成RGB颜色中的r值  </span><br><span class="line">        g=s+random.nextInt(e-s);    //随机生成RGB颜色中的g值  </span><br><span class="line">        b=s+random.nextInt(e-s);    //随机生成RGB颜色中的b值  </span><br><span class="line">        return new Color(r,g,b);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void service(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">        //设置不缓存图片  </span><br><span class="line">        response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);  </span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;, &quot;No-cache&quot;);  </span><br><span class="line">        response.setDateHeader(&quot;Expires&quot;, 0);  </span><br><span class="line">        //指定生成的响应图片,一定不能缺少这句话,否则错误.  </span><br><span class="line">        response.setContentType(&quot;image/jpeg&quot;);  </span><br><span class="line">        int width=86,height=22;     //指定生成验证码的宽度和高度  </span><br><span class="line">        BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //创建BufferedImage对象,其作用相当于一图片  </span><br><span class="line">        Graphics g=image.getGraphics();     //创建Graphics对象,其作用相当于画笔  </span><br><span class="line">        Graphics2D g2d=(Graphics2D)g;       //创建Grapchics2D对象  </span><br><span class="line">        Random random=new Random();  </span><br><span class="line">        Font mfont=new Font(&quot;楷体&quot;,Font.BOLD,16); //定义字体样式  </span><br><span class="line">        g.setColor(getRandColor(200,250));  </span><br><span class="line">        g.fillRect(0, 0, width, height);    //绘制背景  </span><br><span class="line">        g.setFont(mfont);                   //设置字体  </span><br><span class="line">        g.setColor(getRandColor(180,200));  </span><br><span class="line">          </span><br><span class="line">        //绘制100条颜色和位置全部为随机产生的线条,该线条为2f  </span><br><span class="line">        for(int i=0;i&lt;100;i++)&#123;  </span><br><span class="line">            int x=random.nextInt(width-1);  </span><br><span class="line">            int y=random.nextInt(height-1);  </span><br><span class="line">            int x1=random.nextInt(6)+1;  </span><br><span class="line">            int y1=random.nextInt(12)+1;  </span><br><span class="line">            BasicStroke bs=new BasicStroke(2f,BasicStroke.CAP_BUTT,BasicStroke.JOIN_BEVEL); //定制线条样式  </span><br><span class="line">            Line2D line=new Line2D.Double(x,y,x+x1,y+y1);  </span><br><span class="line">            g2d.setStroke(bs);  </span><br><span class="line">            g2d.draw(line);     //绘制直线  </span><br><span class="line">        &#125;  </span><br><span class="line">        //输出由英文，数字，和中文随机组成的验证文字，具体的组合方式根据生成随机数确定。  </span><br><span class="line">        String sRand=&quot;&quot;;  </span><br><span class="line">        String ctmp=&quot;&quot;;  </span><br><span class="line">        int itmp=0;  </span><br><span class="line">        //制定输出的验证码为四位  </span><br><span class="line">        for(int i=0;i&lt;4;i++)&#123;  </span><br><span class="line">            switch(random.nextInt(3))&#123;  </span><br><span class="line">                case 1:     //生成A-Z的字母  </span><br><span class="line">                     itmp=random.nextInt(26)+65;  </span><br><span class="line">                     ctmp=String.valueOf((char)itmp);  </span><br><span class="line">                     break;  </span><br><span class="line">                case 2:     //生成汉字  </span><br><span class="line">                     String[] rBase=&#123;&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;&#125;;   </span><br><span class="line">                     //生成第一位区码  </span><br><span class="line">                     int r1=random.nextInt(3)+11;  </span><br><span class="line">                     String str_r1=rBase[r1];  </span><br><span class="line">                     //生成第二位区码  </span><br><span class="line">                     int r2;  </span><br><span class="line">                     if(r1==13)&#123;  </span><br><span class="line">                         r2=random.nextInt(7);     </span><br><span class="line">                     &#125;else&#123;  </span><br><span class="line">                         r2=random.nextInt(16);  </span><br><span class="line">                     &#125;  </span><br><span class="line">                     String str_r2=rBase[r2];  </span><br><span class="line">                     //生成第一位位码  </span><br><span class="line">                     int r3=random.nextInt(6)+10;  </span><br><span class="line">                     String str_r3=rBase[r3];  </span><br><span class="line">                     //生成第二位位码  </span><br><span class="line">                     int r4;  </span><br><span class="line">                     if(r3==10)&#123;  </span><br><span class="line">                         r4=random.nextInt(15)+1;  </span><br><span class="line">                     &#125;else if(r3==15)&#123;  </span><br><span class="line">                         r4=random.nextInt(15);  </span><br><span class="line">                     &#125;else&#123;  </span><br><span class="line">                         r4=random.nextInt(16);  </span><br><span class="line">                     &#125;  </span><br><span class="line">                     String str_r4=rBase[r4];  </span><br><span class="line">                     //将生成的机内码转换为汉字  </span><br><span class="line">                     byte[] bytes=new byte[2];  </span><br><span class="line">                     //将生成的区码保存到字节数组的第一个元素中  </span><br><span class="line">                     String str_12=str_r1+str_r2;  </span><br><span class="line">                     int tempLow=Integer.parseInt(str_12, 16);  </span><br><span class="line">                     bytes[0]=(byte) tempLow;  </span><br><span class="line">                     //将生成的位码保存到字节数组的第二个元素中  </span><br><span class="line">                     String str_34=str_r3+str_r4;  </span><br><span class="line">                     int tempHigh=Integer.parseInt(str_34, 16);  </span><br><span class="line">                     bytes[1]=(byte)tempHigh;  </span><br><span class="line">                     ctmp=new String(bytes);  </span><br><span class="line">                     break;  </span><br><span class="line">                default:  </span><br><span class="line">                     itmp=random.nextInt(10)+48;  </span><br><span class="line">                     ctmp=String.valueOf((char)itmp);  </span><br><span class="line">                     break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            sRand+=ctmp;  </span><br><span class="line">            Color color=new Color(20+random.nextInt(110),20+random.nextInt(110),random.nextInt(110));  </span><br><span class="line">            g.setColor(color);  </span><br><span class="line">            //将生成的随机数进行随机缩放并旋转制定角度 PS.建议不要对文字进行缩放与旋转,因为这样图片可能不正常显示  </span><br><span class="line">            /*将文字旋转制定角度*/  </span><br><span class="line">            Graphics2D g2d_word=(Graphics2D)g;  </span><br><span class="line">            AffineTransform trans=new AffineTransform();  </span><br><span class="line">            trans.rotate((45)*3.14/180,15*i+8,7);  </span><br><span class="line">            /*缩放文字*/  </span><br><span class="line">            float scaleSize=random.nextFloat()+0.8f;  </span><br><span class="line">            if(scaleSize&gt;1f) scaleSize=1f;  </span><br><span class="line">            trans.scale(scaleSize, scaleSize);  </span><br><span class="line">            g2d_word.setTransform(trans);  </span><br><span class="line">            g.drawString(ctmp, 15*i+18, 14);  </span><br><span class="line">        &#125;  </span><br><span class="line">        HttpSession session=request.getSession(true);  </span><br><span class="line">        session.setAttribute(&quot;randCheckCode&quot;, sRand);  </span><br><span class="line">        g.dispose();    //释放g所占用的系统资源  </span><br><span class="line">        ImageIO.write(image,&quot;JPEG&quot;,response.getOutputStream()); //输出图片  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.配置Servlet</p><pre><code>在web.xml中的配置如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;web-app version=&quot;2.5&quot;   </span><br><span class="line">    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;   </span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   </span><br><span class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee   </span><br><span class="line">    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;  </span><br><span class="line">  &lt;servlet&gt;  </span><br><span class="line">    &lt;description&gt;输出验证码&lt;/description&gt;  </span><br><span class="line">    &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt;  </span><br><span class="line">    &lt;servlet-name&gt;PictureCheckCode&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;servlet-class&gt;com.servlet.PictureCheckCode&lt;/servlet-class&gt;  </span><br><span class="line">  &lt;/servlet&gt;  </span><br><span class="line">  </span><br><span class="line">  &lt;servlet-mapping&gt;  </span><br><span class="line">    &lt;servlet-name&gt;PictureCheckCode&lt;/servlet-name&gt;  </span><br><span class="line">    &lt;url-pattern&gt;/&lt;SPAN style=&quot;COLOR: #ff0000&quot;&gt;PictureCheckCode&lt;/SPAN&gt;&lt;/url-pattern&gt;  </span><br><span class="line">  &lt;/servlet-mapping&gt;  </span><br><span class="line">  &lt;welcome-file-list&gt;  </span><br><span class="line">    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;  </span><br><span class="line">  &lt;/welcome-file-list&gt;  </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>3.测试验证码<br>      可以编写JSP页面来验证是否可以输出验证码图片,JSP代码如下：</p><pre><code>1.index.jsp:显示界面</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gbk&quot;%&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">        &lt;title&gt;验证码&lt;/title&gt;  </span><br><span class="line">        &lt;script language=&quot;javascript&quot;&gt;  </span><br><span class="line">function myReload() &#123;  </span><br><span class="line">    document.getElementById(&quot;CreateCheckCode&quot;).src = document  </span><br><span class="line">            .getElementById(&quot;CreateCheckCode&quot;).src  </span><br><span class="line">            + &quot;?nocache=&quot; + new Date().getTime();  </span><br><span class="line">&#125;  </span><br><span class="line">&lt;/script&gt;  </span><br><span class="line">    &lt;/head&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;body&gt;  </span><br><span class="line">        &lt;form action=&quot;Check.jsp&quot; method=&quot;post&quot;&gt;  </span><br><span class="line">            &lt;input name=&quot;checkCode&quot; type=&quot;text&quot; id=&quot;checkCode&quot; title=&quot;验证码区分大小写&quot;  </span><br><span class="line">                size=&quot;8&quot; ,maxlength=&quot;4&quot; /&gt;  </span><br><span class="line">            &lt;img src=&quot;PictureCheckCode&quot; id=&quot;CreateCheckCode&quot; align=&quot;middle&quot;&gt;  </span><br><span class="line">            &lt;a href=&quot;&quot; onclick=&quot;myReload()&quot;&gt; 看不清,换一个&lt;/a&gt;  </span><br><span class="line">            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;  </span><br><span class="line">        &lt;/form&gt;  </span><br><span class="line">    &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><pre><code>2.Check.jsp :主要验证提交的数据是否和Session中保存的验证码是否相同</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gbk&quot;%&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">  &lt;head&gt;  </span><br><span class="line">    &lt;title&gt;验证码校验&lt;/title&gt;  </span><br><span class="line">  &lt;/head&gt;  </span><br><span class="line">    </span><br><span class="line">  &lt;body&gt;  </span><br><span class="line">    &lt;%  </span><br><span class="line">        String checkcode=request.getParameter(&quot;checkCode&quot;);  </span><br><span class="line">        if(checkcode.equals(&quot;&quot;)||checkcode==null)&#123;  </span><br><span class="line">            out.print(&quot;&lt;script&gt;alert(&apos;请输入验证码&apos;);window.location.href(&apos;index.jsp&apos;)&lt;/script&gt;&quot;);  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            if(!checkcode.equalsIgnoreCase((String)session.getAttribute(&quot;randCheckCode&quot;)))&#123;  </span><br><span class="line">                out.print(&quot;&lt;script&gt;alert(&apos;验证码不正确,请重新输入&apos;);history.back(-1);&lt;/script&gt;&quot;);  </span><br><span class="line">            &#125;else&#123;  </span><br><span class="line">                out.print(&quot;登录成功&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">     %&gt;  </span><br><span class="line">  &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/lulei9876/article/details/8365500/" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是验证码及它的作用&lt;br&gt;    验证码为全自动区分计算机和人类的图灵测试的缩写,是一种区分用户是计算机的公共全自动程序,这个问题可以由计算机生成并评判,但是必须只有人类才能解答.可以防止恶意破解密码、刷票、论坛灌水、有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录。
    
    </summary>
    
      <category term="java" scheme="http://baiyuechu.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://baiyuechu.github.io/tags/java/"/>
    
      <category term="identity" scheme="http://baiyuechu.github.io/tags/identity/"/>
    
  </entry>
  
  <entry>
    <title>建站小结</title>
    <link href="http://baiyuechu.github.io/2018/10/05/bulidSummary/"/>
    <id>http://baiyuechu.github.io/2018/10/05/bulidSummary/</id>
    <published>2018-10-05T14:06:13.191Z</published>
    <updated>2017-03-20T11:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本来已经搞定，本地预览没有问题，上传到github上却出现了问题，又纠结了几天。。。<a id="more"></a></p><p>接下来说说建站的过程吧，/(ㄒoㄒ)/~~。</p><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>先安装node.js,去官网下，一直next就好，一般不用配（node.js是js运行平台，封装了Google V8引擎，具有轻量高效的特点，用它能快速生成页面）</p><h3 id="然后安装git"><a href="#然后安装git" class="headerlink" title="然后安装git"></a>然后安装git</h3><p>（一个分布式的版本管理工具，把本地的hexo内容提交到github），一直next就好。。。</p><h3 id="注册github账号"><a href="#注册github账号" class="headerlink" title="注册github账号"></a>注册github账号</h3><p>建仓库，注意仓库名 username.git.io 这样就能直接通过username.git.io访问博客页面了</p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>node.js和git都安装好后，首先创建一个文件夹（如blog）用来存放hexo的配置文件<br>进入刚才创建的文件夹中（blog）鼠标右键选择git bash here 执行如下命令<br>    <code>npm install -g hexo</code>    或者 <code>npm install hexo-deployer-git --save</code>(##命令千万不要错了。。。##)<br>成功之后执行init命令初始化hexo<br>    <code>hexo init</code><br>然后执行<code>hexo s</code>，根据提示可以在本地预览hexo的初始模板</p><h3 id="博客文件夹中有一些文件"><a href="#博客文件夹中有一些文件" class="headerlink" title="博客文件夹中有一些文件"></a>博客文件夹中有一些文件</h3><blockquote><p>   node_modules： 存放hexo的依赖插件<br>   source： 存放我们写的文章<br>   themes： 存放主题文件<br>   _config.yml：hexo配置文件（站点配置文件）</p></blockquote><p>然后去配置一下显示隐藏的文件，目录中没有.git文件夹的话就执行<code>git init</code><br>之后就能看见.git文件了，这是为了能用git上传<br><strong>安装基本完成</strong><br>我之前就是命令打错了，文件目录有个.npmignore的文件，导致之后用git上传的时候将整个文件夹的内容都上传到github，然后还傻傻的去访问自己的博客主页，一直404，又去百度各种找答案，唉，说多了都是泪。。。<br>正常目录不是.npmignore文件而是.gitignore文件</p><h3 id="配置sshkey"><a href="#配置sshkey" class="headerlink" title="配置sshkey"></a>配置sshkey</h3><p>还是在你博客文件目录下执行<br><code>git config --global user.name &quot;githubName&quot;git config --global user.email &quot;githubEmail&quot;</code><br>生成key<br><code>ssh-keygen -t rsa -C &quot;githubEmail&quot;</code><br>然后看提示，正常一路回车就行<br>之后就去到C:\Users\Administrator.ssh将id_rsa.pub用记事本打开，复制里面的内容<br>进入你的github仓库点击上面的setting，右边的deploy keys<br>填好标题（任意，长点具体点更好）<br>再将你刚才复制的东西放在key里，勾上下面的允许改写，点击add key就行了<br>然后在回到本地执行<code>ssh -T git@github.com</code>测试下是否成功，成功的话仓库那边的钥匙也会变成绿色的<br>到这里配置就完成了，我们就可以开始写我们自己的博客了</p><h3 id="模板的选择"><a href="#模板的选择" class="headerlink" title="模板的选择"></a>模板的选择</h3><p>这里贴个链接，是一些主题推荐<br><a href="https://www.aswifter.com/2016/01/18/hexo-themes/" target="_blank" rel="noopener">Hexo博客主题推荐</a><br>选好主题后，复制地址（复制好的地址一般以.git结尾），使用命令<code>git clone address</code> copy到本地，然后将模板文件放在themes文件夹中</p><h3 id="config-yml文件的配置"><a href="#config-yml文件的配置" class="headerlink" title="_config.yml文件的配置"></a>_config.yml文件的配置</h3><p>该文件就在博客目录下，用于博客的一些主要配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: 月初</span><br><span class="line">subtitle: 别打我，我知道我很蠢。。。</span><br><span class="line">description:</span><br><span class="line">author: 月初</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://baiyuechu.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yelee</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"></span><br><span class="line">  repo: https://github.com/baiyuechu/baiyuechu.github.io.git</span><br><span class="line"></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>以上是我的博客配置，按需要更改即可</p><h3 id="yelee主题使用"><a href="#yelee主题使用" class="headerlink" title="yelee主题使用"></a>yelee主题使用</h3><p>还是贴个链接吧<br><a href="http://moxfive.coding.me/yelee/2.Basic-Usage/post-excerpt.html" target="_blank" rel="noopener">yelee主题使用说明</a></p><h3 id="开始写博客"><a href="#开始写博客" class="headerlink" title="开始写博客"></a>开始写博客</h3><p>source/_posts文件夹下新建.md文件<br>markdown的语法规则挺简单，就不多说了（虽然很简单，但是百度到的自己写了，却预览不出该有的效果/(ㄒoㄒ)/~~ 还是找个机会写篇博客吧。。。）<br>说一下设置标签吧，在开头添加<code>tags: [java]</code>即可,有多个标签的话，用逗号隔开即可<br>右边的有个标签云页面，怎么设置的说明文档上并没有详细的说明，又要缠着度娘去了/(ㄒoㄒ)/~~。。。<br>之后写个详细点的使用说明吧<br>那么，就到这里了，嘉㖏</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=34609107&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来已经搞定，本地预览没有问题，上传到github上却出现了问题，又纠结了几天。。。
    
    </summary>
    
      <category term="study" scheme="http://baiyuechu.github.io/categories/study/"/>
    
    
      <category term="experience" scheme="http://baiyuechu.github.io/tags/experience/"/>
    
  </entry>
  
  <entry>
    <title>建站第一天纪念</title>
    <link href="http://baiyuechu.github.io/2018/10/05/birthday/"/>
    <id>http://baiyuechu.github.io/2018/10/05/birthday/</id>
    <published>2018-10-05T14:06:13.175Z</published>
    <updated>2017-02-22T12:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个这么简单的东西搞了好几天才把它弄好。。。。好蠢。。。<a id="more"></a><br><img src="https://baiyuechu.github.io/img/susu7_.png" alt="load..."></p><p>而且还有些地方不完善。。。之后再说吧。</p><p>建站初衷：记录自己学习笔记，心得，以及生活琐事</p><iframe height="100" width="400" src="//music.163.com/outchain/player?type=2&id=586029&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个这么简单的东西搞了好几天才把它弄好。。。。好蠢。。。
    
    </summary>
    
      <category term="Live" scheme="http://baiyuechu.github.io/categories/Live/"/>
    
    
      <category term="live" scheme="http://baiyuechu.github.io/tags/live/"/>
    
  </entry>
  
  <entry>
    <title>驱动模式 ModelDriven</title>
    <link href="http://baiyuechu.github.io/2018/10/05/2/"/>
    <id>http://baiyuechu.github.io/2018/10/05/2/</id>
    <published>2018-10-05T14:06:13.175Z</published>
    <updated>2017-03-20T12:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要用途：便捷的添加实体类的字段，不用一个个添加字段，直接声明一下实体类，设置一下set()即可<a id="more"></a></p><p>具体用法：action中实现ModelDriven （注意后面一定要加泛型）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionSupport implements ModelDriven&lt;Product&gt;</span><br></pre></td></tr></table></figure></p><p>然后<br>new出泛型中的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Product product = new Product()</span><br></pre></td></tr></table></figure></p><p>接着实现ModelDriven接口中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Product getModel()&#123;</span><br><span class="line">return product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就行了，Action会去自动调用Product的setter将表单中的属性的值赋给Product中的属性</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=646465&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要用途：便捷的添加实体类的字段，不用一个个添加字段，直接声明一下实体类，设置一下set()即可
    
    </summary>
    
      <category term="java" scheme="http://baiyuechu.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://baiyuechu.github.io/tags/java/"/>
    
      <category term="struts" scheme="http://baiyuechu.github.io/tags/struts/"/>
    
  </entry>
  
  <entry>
    <title>声明式事务管理</title>
    <link href="http://baiyuechu.github.io/2018/10/05/1/"/>
    <id>http://baiyuechu.github.io/2018/10/05/1/</id>
    <published>2018-10-05T14:06:13.159Z</published>
    <updated>2017-03-20T12:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方式一，全在spring配置"><a href="#方式一，全在spring配置" class="headerlink" title="方式一，全在spring配置"></a>方式一，全在spring配置<a id="more"></a></h3><pre><code>spring 中的配置文件：</code></pre><blockquote><p>   <code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</code><br>       <code>&lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;</code><br>   <code>&lt;/bean&gt;</code></p><p>   <code>&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</code><br>       <code>&lt;tx:attributes&gt;</code><br>           <code>&lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;&lt;!-- 符合表达式的即可添加事务 --&gt;</code><br>           <code>&lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; /&gt;</code><br>           <code>&lt;tx:method name=&quot;mod*&quot; propagation=&quot;REQUIRED&quot; /&gt;</code><br>           <code>&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt;&lt;!-- 只读 --&gt;</code><br>       <code>&lt;/tx:attributes&gt;</code><br>   <code>&lt;/tx:advice&gt;</code></p><p>   <code>&lt;aop:config&gt;</code><br>       <code>&lt;aop:pointcut id=&quot;interceptorPointCuts&quot;           expression=&quot;execution(*         news.service.*.*(..))&quot; /&gt;&lt;!-- 语法：(* packageName.*.*(..) 第二个*为类名，第三个*为方法名 --&gt;</code><br>       <code>&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;interceptorPointCuts&quot; /&gt;</code><br>   <code>&lt;/aop:config&gt;</code></p></blockquote><h3 id="方式二，部分在源码中配置："><a href="#方式二，部分在源码中配置：" class="headerlink" title="方式二，部分在源码中配置："></a>方式二，部分在源码中配置：</h3><pre><code>spring中的配置：</code></pre><blockquote><p>   <code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</code><br>       <code>&lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&gt;&lt;/property&gt;</code><br>   <code>&lt;/bean&gt;</code></p><p>   <code>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></p></blockquote><pre><code>源码中的配置：</code></pre><blockquote><p>   <code>@Transactional(readOnly=true)//可在方法名上配置</code><br>   <code>public List showAllNews() {</code></p></blockquote><blockquote><p>   <code>@Transactional//也可在类名上配置，即类中所有方法都会添加事务</code><br>   <code>public class NewsServiceImpl implements NewsService {</code></p></blockquote><p>方法优缺点：</p><table><thead><tr><th>方法一</th><th>方法二</th></tr></thead><tbody><tr><td>在spring配置文件中一次性配置，编程人员比较轻松</td><td>需要到具体的类或方法配置，较麻烦</td></tr><tr><td>较低的阅读性</td><td>较高的阅读性</td></tr><tr><td><strong>降低了耦和性</strong>，项目更好管理</td><td><strong>增加了耦合性</strong>，项目不好管理</td></tr></tbody></table><p>最后，具体用哪种方法看情况而定，本文纯属个人学习经验，如有不正之处，还望指正，感激不尽。<br>（虽然没什么人看 /(ㄒoㄒ)/~~）</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=33337284&auto=1&height=32"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;方式一，全在spring配置&quot;&gt;&lt;a href=&quot;#方式一，全在spring配置&quot; class=&quot;headerlink&quot; title=&quot;方式一，全在spring配置&quot;&gt;&lt;/a&gt;方式一，全在spring配置
    
    </summary>
    
      <category term="java" scheme="http://baiyuechu.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://baiyuechu.github.io/tags/java/"/>
    
      <category term="Transaction" scheme="http://baiyuechu.github.io/tags/Transaction/"/>
    
  </entry>
  
</feed>
